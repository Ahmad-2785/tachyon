#include "tachyon/build/cc_writer.h"

#include "absl/strings/str_join.h"
#include "absl/strings/str_replace.h"
#include "absl/strings/substitute.h"

#include "tachyon/base/logging.h"
#include "tachyon/base/strings/string_util.h"

namespace tachyon::build {

namespace {

// clang-format off
// Case 1. If your build target tries to generate //tachyon/math/elliptic_curves/bn/bn254/g1.h,
// then |components| will be ["bazel-out", "k8-fastbuild", "bin", "tachyon", "math", "elliptic_curves", "bn", "bn254", "g1.h"]
// Case 2. If your build target tries to generate @kroma_network_tachyon//tachyon/math/elliptic_curves/bn/bn254/g1.h,
// then |components| will be ["bazel-out", "k8-fastbuild", "bin", "external", "kroma_network_tachyon", "tachyon", "math", "elliptic_curves", "bn", "bn254", "g1.h"]
// This functions returns 3 for Case 1 and 5 for Case 5.
// clang-format on
size_t CountBazelParts(const std::vector<std::string>& components) {
  CHECK_EQ(components[0], "bazel-out");
  CHECK_EQ(components[2], "bin");
  if (components[3] == "external") {
    return 5;
  }
  return 3;
}

base::FilePath BazelOutToHdrPath(const base::FilePath& out) {
  std::vector<std::string> components = out.GetComponents();
  size_t non_bazel_part = CountBazelParts(components);
  base::FilePath header_path(absl::StrJoin(components.begin() + non_bazel_part,
                                           components.end() - 1,
                                           base::FilePath::kSeparators));
  header_path = header_path.Append(
      absl::StrCat(out.BaseName().RemoveExtension().value(), ".h"));
  return header_path;
}

std::string BazelOutToHdrGuardMacro(const base::FilePath& out) {
  std::vector<std::string> components = out.GetComponents();
  size_t non_bazel_part = CountBazelParts(components);
  base::FilePath header_path(absl::StrJoin(components.begin() + non_bazel_part,
                                           components.end() - 1,
                                           base::FilePath::kSeparators));
  // In case of .cu.h, it removes extension twice.
  base::FilePath basename = out.BaseName().RemoveExtension().RemoveExtension();
  return base::ToUpperASCII(
      absl::StrCat(absl::StrJoin(components.begin() + non_bazel_part,
                                 components.end() - 1, "_"),
                   absl::Substitute("_$0_H_", basename.value())));
}

}  // namespace

base::FilePath CcWriter::GetHdrPath() const { return BazelOutToHdrPath(out); }

int CcWriter::WriteHdr(const std::string& content, bool c_api) const {
  std::string_view tpl[] = {
      "// This is generated by %{generator}",
      "#ifndef %{header_guard_macro}",
      "#define %{header_guard_macro}",
      "",
      "%{content}",
      "%{extern_c_back}",
      "#endif  // %{header_guard_macro}",
      "",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string_view extern_c_front =
      "#ifdef __cplusplus\n"
      "extern \"C\" {\n"
      "#endif";

  std::string_view extern_c_back =
      "\n"
      "#ifdef __cplusplus\n"
      "}  // extern \"C\"\n"
      "#endif\n";

  tpl_content = absl::StrReplaceAll(tpl_content, {
                                                     {"%{content}", content},
                                                 });

  std::string text = absl::StrReplaceAll(
      tpl_content,
      {
          {"%{generator}", generator},
          {"%{header_guard_macro}", BazelOutToHdrGuardMacro(out)},
          {"%{extern_c_front}", c_api ? std::string(extern_c_front) : ""},
          {"%{extern_c_back}", c_api ? std::string(extern_c_back) : ""},
      });
  return Write(text);
}

int CcWriter::WriteSrc(const std::string& content) const {
  std::vector<std::string_view> tpl = {
      "// This is generated by %{generator}",
      "#include \"%{header_path}\"",
      "",
      "%{content}"
      "",
  };
  std::string tpl_content = absl::StrJoin(tpl, "\n");

  std::string text = absl::StrReplaceAll(
      tpl_content, {
                       {"%{generator}", generator},
                       {"%{header_path}", GetHdrPath().value()},
                       {"%{content}", content},
                   });
  return Write(text);
}

}  // namespace tachyon::build
